{{/*
Encode blocks for multi-statement field encoders, used when the simple
EncodeExpr hook is not sufficient (e.g. maps and slices that need
inline loops). These are shape-based (map/slice element types), not
per-field, mirroring msgp-style codegen.

Templates:
  encodeMapUint64PtrMarshaler - map[uint64]*T where *T has MarshalCBOR
  encodeMapUint64Uint64       - map[uint64]uint64
  encodeMapStrStr             - map[string]string
  encodeMapStrValueMarshaler  - map[string]T where T has MarshalCBOR
  encodeMapStrPtrMarshaler    - map[string]*T where *T has MarshalCBOR
  encodeMapStrScalar          - map[string]S where S is a scalar
  encodeSlicePtrMarshaler     - []*T where *T has MarshalCBOR
  encodeSliceValueMarshaler   - []T where T has MarshalCBOR
  encodeSliceScalar           - []S where S is a scalar (bool/int/float/string)

Inputs:
  .FieldRef   - "x.F" reference to the Go field
  .KeyName    - CBOR map/array key name
  .GoField    - Go field name (for variable suffixes)
  .ElemVar    - Loop variable name used for slice elements
  .AppendFunc - cbor.Append* helper name for scalar slices
*/}}

{{define "encodeMapUint64PtrMarshaler"}}
	b = cbor.AppendString(b, "{{.KeyName}}")
	b = cbor.AppendMapHeader(b, uint32(len({{.FieldRef}})))
	for k, v := range {{.FieldRef}} {
		b = cbor.AppendUint64(b, k)
		if v == nil {
			b = cbor.AppendNil(b)
		} else {
			b, err = v.MarshalCBOR(b)
			if err != nil { return b, err }
		}
	}
{{end}}

{{define "encodeMapUint64Uint64"}}
	b = cbor.AppendString(b, "{{.KeyName}}")
	b = cbor.AppendMapHeader(b, uint32(len({{.FieldRef}})))
	for k, v := range {{.FieldRef}} {
		b = cbor.AppendUint64(b, k)
		b = cbor.AppendUint64(b, v)
	}
{{end}}

{{define "encodeMapStrStr"}}
	b = cbor.AppendString(b, "{{.KeyName}}")
	b = cbor.AppendMapHeader(b, uint32(len({{.FieldRef}})))
	for k, v := range {{.FieldRef}} {
		b = cbor.AppendString(b, k)
		b = cbor.AppendString(b, v)
	}
{{end}}

{{define "encodeMapStrValueMarshaler"}}
	b = cbor.AppendString(b, "{{.KeyName}}")
	b = cbor.AppendMapHeader(b, uint32(len({{.FieldRef}})))
	for k, v := range {{.FieldRef}} {
		b = cbor.AppendString(b, k)
		b, err = v.MarshalCBOR(b)
		if err != nil { return b, err }
	}
{{end}}

{{define "encodeMapStrPtrMarshaler"}}
	b = cbor.AppendString(b, "{{.KeyName}}")
	b = cbor.AppendMapHeader(b, uint32(len({{.FieldRef}})))
	for k, v := range {{.FieldRef}} {
		b = cbor.AppendString(b, k)
		if v == nil {
			b = cbor.AppendNil(b)
		} else {
			b, err = v.MarshalCBOR(b)
			if err != nil { return b, err }
		}
	}
{{end}}

{{define "encodeMapStrScalar"}}
	b = cbor.AppendString(b, "{{.KeyName}}")
	b = cbor.AppendMapHeader(b, uint32(len({{.FieldRef}})))
	for k, v := range {{.FieldRef}} {
		b = cbor.AppendString(b, k)
		b = cbor.{{.AppendFunc}}(b, v)
	}
{{end}}

{{define "encodeSlicePtrMarshaler"}}
	b = cbor.AppendString(b, "{{.KeyName}}")
	b = cbor.AppendArrayHeader(b, uint32(len({{.FieldRef}})))
	for _, {{.ElemVar}} := range {{.FieldRef}} {
		if {{.ElemVar}} == nil {
			b = cbor.AppendNil(b)
		} else {
			b, err = {{.ElemVar}}.MarshalCBOR(b)
			if err != nil { return b, err }
		}
	}
{{end}}

{{define "encodeSliceValueMarshaler"}}
	b = cbor.AppendString(b, "{{.KeyName}}")
	b = cbor.AppendArrayHeader(b, uint32(len({{.FieldRef}})))
	for i := range {{.FieldRef}} {
		b, err = {{.FieldRef}}[i].MarshalCBOR(b)
		if err != nil { return b, err }
	}
{{end}}

{{define "encodeSliceScalar"}}
	b = cbor.AppendString(b, "{{.KeyName}}")
	b = cbor.AppendArrayHeader(b, uint32(len({{.FieldRef}})))
	for _, v := range {{.FieldRef}} {
		b = cbor.{{.AppendFunc}}(b, v)
	}
{{end}}
