// Code generated by cborgen DO NOT EDIT.

package structs

func (x Person) Msgsize() (s int) {
	s = MapHeaderSize + StringPrefixSize + len("name") + StringPrefixSize + len(x.Name) + StringPrefixSize + len("age") + IntSize + StringPrefixSize + len("data") + BytesPrefixSize + len(x.Data)
	return
}

func (x *Person) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return AppendNil(b), nil
	}

	b = Require(b, x.Msgsize())

	count := uint32(0)
	count++
	if !(x.Age == 0) {
		count++
	}
	count++
	b = AppendMapHeader(b, count)
	var err error
	b = AppendString(b, "name")
	b, err = AppendString(b, x.Name), nil
	if err != nil {
		return b, err
	}
	if !(x.Age == 0) {
		b = AppendString(b, "age")
		b, err = AppendInt(b, x.Age), nil
		if err != nil {
			return b, err
		}
	}
	b = AppendString(b, "data")
	b, err = AppendInterface(b, x.Data)
	if err != nil {
		return b, err
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *Person) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, ErrNotNil
	}
	sz, rest, err := ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := ReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "name":

			var tmp string
			tmp, v, err = ReadStringBytes(v)
			if err != nil {
				return b, err
			}
			x.Name = tmp
		case "age":

			var tmp int
			tmp, v, err = ReadIntBytes(v)
			if err != nil {
				return b, err
			}
			x.Age = tmp
		case "data":

			var tmp []byte
			tmp, v, err = ReadBytesBytes(v, nil)
			if err != nil {
				return b, err
			}
			x.Data = tmp
		default:
			v, err = Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *Person) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, ErrNotNil
	}
	sz, rest, err := ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := ReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := UnsafeString(keyBytes)
		switch key {
		case "name":

			var tmpBytes []byte
			tmpBytes, v, err = ReadStringZC(v)
			if err != nil {
				return b, err
			}
			x.Name = UnsafeString(tmpBytes)
		case "age":

			var tmp int
			tmp, v, err = ReadIntBytes(v)
			if err != nil {
				return b, err
			}
			x.Age = tmp
		case "data":

			var tmp []byte
			tmp, v, err = ReadBytesBytes(v, nil)
			if err != nil {
				return b, err
			}
			x.Data = tmp
		default:
			v, err = Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *Person) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}
