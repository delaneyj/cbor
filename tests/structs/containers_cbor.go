// Code generated by cborgen DO NOT EDIT.

package structs

import cbor "github.com/delaneyj/cbor/runtime"

func (x Containers) Msgsize() (s int) {
	s = cbor.MapHeaderSize + cbor.StringPrefixSize + len("items") + cbor.ArrayHeaderSize + len(x.Items)*0 + cbor.StringPrefixSize + len("map") + cbor.MapHeaderSize + len(x.Map)*(cbor.StringPrefixSize+0)
	return
}

func (x *Containers) MarshalCBOR(b []byte) ([]byte, error) {
	if x == nil {
		return cbor.AppendNil(b), nil
	}

	b = cbor.Require(b, x.Msgsize())

	b = cbor.AppendMapHeader(b, 4)
	var err error
	b = cbor.AppendString(b, "items")
	b, err = cbor.AppendInterface(b, x.Items)
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "ptrs")
	b, err = cbor.AppendInterface(b, x.Ptrs)
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "map")
	b, err = cbor.AppendInterface(b, x.Map)
	if err != nil {
		return b, err
	}
	b = cbor.AppendString(b, "ptr_map")
	b, err = cbor.AppendInterface(b, x.PtrMap)
	if err != nil {
		return b, err
	}

	return b, nil
}

// DecodeSafe decodes using validated, allocating string handling.
func (x *Containers) DecodeSafe(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		key, v, err := cbor.ReadStringBytes(rest)
		if err != nil {
			return b, err
		}
		switch key {
		case "items":

			var sz uint32
			sz, v, err = cbor.ReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Items) >= int(sz) {
				x.Items = x.Items[:sz]
			} else {
				x.Items = make([]Scalars, sz)
			}
			for iItems := uint32(0); iItems < sz; iItems++ {
				var tmp Scalars
				v, err = (&tmp).UnmarshalCBOR(v)
				if err != nil {
					return b, err
				}
				x.Items[iItems] = tmp
			}
		case "ptrs":

			var sz uint32
			sz, v, err = cbor.ReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Ptrs) >= int(sz) {
				x.Ptrs = x.Ptrs[:sz]
			} else {
				x.Ptrs = make([]*Scalars, sz)
			}
			for iPtrs := uint32(0); iPtrs < sz; iPtrs++ {
				if x.Ptrs[iPtrs] == nil {
					x.Ptrs[iPtrs] = new(Scalars)
				}
				v, err = x.Ptrs[iPtrs].UnmarshalCBOR(v)
				if err != nil {
					return b, err
				}
			}
		case "map":

			var sz uint32
			sz, v, err = cbor.ReadMapHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if x.Map == nil && sz > 0 {
				x.Map = make(map[string]Scalars, sz)
			} else if x.Map != nil {
				for k := range x.Map {
					delete(x.Map, k)
				}
			}
			for iMap := uint32(0); iMap < sz; iMap++ {
				var key string
				key, v, err = cbor.ReadStringBytes(v)
				if err != nil {
					return b, err
				}
				var tmp Scalars
				v, err = (&tmp).UnmarshalCBOR(v)
				if err != nil {
					return b, err
				}
				x.Map[key] = tmp
			}
		case "ptr_map":

			var sz uint32
			sz, v, err = cbor.ReadMapHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if x.PtrMap == nil && sz > 0 {
				x.PtrMap = make(map[string]*Scalars, sz)
			} else if x.PtrMap != nil {
				for k := range x.PtrMap {
					delete(x.PtrMap, k)
				}
			}
			for iPtrMap := uint32(0); iPtrMap < sz; iPtrMap++ {
				var key string
				key, v, err = cbor.ReadStringBytes(v)
				if err != nil {
					return b, err
				}
				tmp := new(Scalars)
				v, err = tmp.UnmarshalCBOR(v)
				if err != nil {
					return b, err
				}
				x.PtrMap[key] = tmp
			}
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// DecodeTrusted decodes using zero-copy strings and no per-string UTF-8 validation.
func (x *Containers) DecodeTrusted(b []byte) ([]byte, error) {
	if x == nil {
		return b, cbor.ErrNotNil
	}
	sz, rest, err := cbor.ReadMapHeaderBytes(b)
	if err != nil {
		return b, err
	}
	for i := uint32(0); i < sz; i++ {
		keyBytes, v, err := cbor.ReadStringZC(rest)
		if err != nil {
			return b, err
		}
		key := cbor.UnsafeString(keyBytes)
		switch key {
		case "items":

			var sz uint32
			sz, v, err = cbor.ReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Items) >= int(sz) {
				x.Items = x.Items[:sz]
			} else {
				x.Items = make([]Scalars, sz)
			}
			for iItems := uint32(0); iItems < sz; iItems++ {
				var tmp Scalars
				v, err = (&tmp).UnmarshalCBOR(v)
				if err != nil {
					return b, err
				}
				x.Items[iItems] = tmp
			}
		case "ptrs":

			var sz uint32
			sz, v, err = cbor.ReadArrayHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if cap(x.Ptrs) >= int(sz) {
				x.Ptrs = x.Ptrs[:sz]
			} else {
				x.Ptrs = make([]*Scalars, sz)
			}
			for iPtrs := uint32(0); iPtrs < sz; iPtrs++ {
				if x.Ptrs[iPtrs] == nil {
					x.Ptrs[iPtrs] = new(Scalars)
				}
				v, err = x.Ptrs[iPtrs].UnmarshalCBOR(v)
				if err != nil {
					return b, err
				}
			}
		case "map":

			var sz uint32
			sz, v, err = cbor.ReadMapHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if x.Map == nil && sz > 0 {
				x.Map = make(map[string]Scalars, sz)
			} else if x.Map != nil {
				for k := range x.Map {
					delete(x.Map, k)
				}
			}
			for iMap := uint32(0); iMap < sz; iMap++ {
				var key string
				key, v, err = cbor.ReadStringBytes(v)
				if err != nil {
					return b, err
				}
				var tmp Scalars
				v, err = (&tmp).UnmarshalCBOR(v)
				if err != nil {
					return b, err
				}
				x.Map[key] = tmp
			}
		case "ptr_map":

			var sz uint32
			sz, v, err = cbor.ReadMapHeaderBytes(v)
			if err != nil {
				return b, err
			}
			if x.PtrMap == nil && sz > 0 {
				x.PtrMap = make(map[string]*Scalars, sz)
			} else if x.PtrMap != nil {
				for k := range x.PtrMap {
					delete(x.PtrMap, k)
				}
			}
			for iPtrMap := uint32(0); iPtrMap < sz; iPtrMap++ {
				var key string
				key, v, err = cbor.ReadStringBytes(v)
				if err != nil {
					return b, err
				}
				tmp := new(Scalars)
				v, err = tmp.UnmarshalCBOR(v)
				if err != nil {
					return b, err
				}
				x.PtrMap[key] = tmp
			}
		default:
			v, err = cbor.Skip(v)
			if err != nil {
				return b, err
			}
		}
		rest = v
	}
	return rest, nil
}

// UnmarshalCBOR implements cbor.Unmarshaler using the Safe path.
func (x *Containers) UnmarshalCBOR(b []byte) ([]byte, error) {
	return x.DecodeSafe(b)
}
